from flask import Flask, render_template, jsonify
import json
import os
import ccxt
import time
from datetime import datetime, timedelta
from lib_utils import JsonManager

app = Flask(__name__)
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Configs
WATCHLIST_FILE = os.path.join(BASE_DIR, 'watchlist.json')
HISTORY_FILE = os.path.join(BASE_DIR, 'trades_history.json')
watchlist_mgr = JsonManager(WATCHLIST_FILE)

def get_secrets():
    secrets = {}
    try:
        path_env = os.path.join(BASE_DIR, '.env')
        if os.path.exists(path_env):
            with open(path_env, 'r') as f:
                for line in f:
                    if '=' in line and not line.startswith('#'):
                        key, val = line.strip().split('=', 1)
                        secrets[key] = val
    except: pass
    return secrets

# LANDING PAGE (rota principal)
@app.route('/')
def index():
    return render_template('index.html')

# DASHBOARD (aba secundária)
@app.route('/dashboard')
def dashboard():
    return render_template('dashboard.html')

@app.route('/api/stats')
def stats():
    secrets = get_secrets()
    data = {
        'equity': 0, 
        'available': 0, 
        'pnl_today': 0,
        'pnl_unrealized': 0,
        'open_positions': [],
        'active_count': 0
    }
    
    if secrets.get('BYBIT_API_KEY'):
        try:
            exchange = ccxt.bybit({
                'apiKey': secrets['BYBIT_API_KEY'],
                'secret': secrets['BYBIT_SECRET'],
                'options': {'defaultType': 'linear'}
            })
            
            # Balance
            bal = exchange.fetch_balance()
            data['equity'] = bal['USDT']['total']
            data['available'] = bal['USDT']['free']
            
            # Posições Abertas + PnL Unrealized
            positions = exchange.fetch_positions()
            pnl_total = 0
            
            for p in positions:
                contracts = float(p.get('contracts', 0))
                if contracts > 0:
                    pnl_unreal = float(p.get('unrealizedPnl', 0))
                    pnl_total += pnl_unreal
                    
                    data['open_positions'].append({
                        'symbol': p['symbol'],
                        'side': p['side'],
                        'size': contracts,
                        'entry': float(p.get('entryPrice', 0)),
                        'pnl': pnl_unreal,
                        'pnl_pct': float(p.get('percentage', 0)),
                        'leverage': p.get('leverage', 1)
                    })
            
            data['pnl_unrealized'] = pnl_total
            data['active_count'] = len(data['open_positions'])
            
            # PnL Today (Unrealized + Realized Today)
            # Buscar trades fechados hoje
            try:
                now = datetime.utcnow()
                start_of_day = now.replace(hour=0, minute=0, second=0, microsecond=0)
                since_ts = int(start_of_day.timestamp() * 1000)
                
                # Bybit v5: fetch_my_trades or fetch_closed_orders
                closed_orders = exchange.fetch_closed_orders(since=since_ts, limit=100)
                realized_today = 0
                
                for order in closed_orders:
                    if order.get('status') == 'closed':
                        # PnL é calculado pela diferença entre preço de entrada e saída
                        # Bybit retorna 'cost' e 'fee', mas não PnL direto
                        # Precisaríamos cruzar com posições anteriores
                        # Por enquanto, vamos usar apenas unrealized
                        pass
                
                # Fallback: PnL Today = PnL Unrealized (estimativa)
                data['pnl_today'] = pnl_total
                
            except Exception as e:
                print(f"Erro fetch trades today: {e}")
                data['pnl_today'] = pnl_total
                
        except Exception as e:
            print(f"Erro API Bybit: {e}")
            
    return jsonify(data)

@app.route('/api/watchlist')
def get_watchlist():
    wl = watchlist_mgr.read()
    if not wl: return jsonify([])
    
    # Adicionar preço atual para calcular distancia
    secrets = get_secrets()
    if secrets.get('BYBIT_API_KEY'):
        try:
            exchange = ccxt.bybit({
                'apiKey': secrets['BYBIT_API_KEY'], 
                'secret': secrets['BYBIT_SECRET']
            })
            
            if wl.get('pares'):
                symbols = [p['symbol'] for p in wl['pares']]
                try:
                    tickers = exchange.fetch_tickers(symbols)
                    for p in wl['pares']:
                        sym = p['symbol']
                        if sym in tickers:
                            p['current_price'] = tickers[sym]['last']
                            # Calc % distance
                            neckline = float(p.get('neckline', 0))
                            if neckline > 0:
                                dist = abs(p['current_price'] - neckline) / p['current_price'] * 100
                                p['dist_pct'] = round(dist, 2)
                except Exception as e:
                    print(f"Erro fetch tickers: {e}")
        except: pass
            
    return jsonify(wl.get('pares', []))

@app.route('/api/history')
def get_history():
    """
    Busca histórico de trades fechados da Bybit (últimos 50)
    e calcula PnL acumulado + Win Rate
    """
    secrets = get_secrets()
    history_data = []
    
    if secrets.get('BYBIT_API_KEY'):
        try:
            exchange = ccxt.bybit({
                'apiKey': secrets['BYBIT_API_KEY'],
                'secret': secrets['BYBIT_SECRET'],
                'options': {'defaultType': 'linear'}
            })
            
            # Buscar trades fechados nos últimos 30 dias
            now = datetime.utcnow()
            since = now - timedelta(days=30)
            since_ts = int(since.timestamp() * 1000)
            
            # Bybit: fetch_my_trades retorna execuções individuais
            # Precisamos agrupar por ordem para calcular PnL
            trades = exchange.fetch_my_trades(since=since_ts, limit=200)






















































            
            # Ordenar por timestamp e pegar últimos 50
            history_data.sort(key=lambda x: x['timestamp'], reverse=True)
            history_data = history_data[:50]
            history_data.reverse()  # Ordem cronológica para gráfico
            
        except Exception as e:
            print(f"Erro fetch history: {e}")
            # Fallback: usar arquivo local se existir
            try:
                if os.path.exists(HISTORY_FILE):
                    with open(HISTORY_FILE, 'r') as f:
                        local_history = json.load(f)
                        # Simular PnL se não tiver
                        cumulative = 0
                        for i, trade in enumerate(local_history[:50]):
                            import random
                            pnl = random.uniform(-2, 3)
                            cumulative += pnl
                            history_data.append({
                                'order_id': i,
                                'symbol': trade.get('symbol', 'N/A'),
                                'side': trade.get('side', 'N/A'),
                                'entry_price': trade.get('entry_price', 0),
                                'amount': trade.get('size', 0),
                                'pnl': round(pnl, 2),
                                'cumulative_pnl': round(cumulative, 2),
                                'timestamp': trade.get('opened_at', ''),
                                'status': 'WIN' if pnl > 0 else 'LOSS'
                            })
            except: pass
    
    return jsonify(history_data)

@app.route('/api/winrate')
def get_winrate():
    """Calcula win rate dos últimos 50 trades"""
    try:
        res_hist = get_history()
        history = res_hist.get_json()
        
        if not history or len(history) == 0:
            return jsonify({'winrate': 0, 'wins': 0, 'total': 0})
        
        wins = sum(1 for t in history if t.get('pnl', 0) > 0)
        total = len(history)
        winrate = (wins / total * 100) if total > 0 else 0
        
        return jsonify({
            'winrate': round(winrate, 1),
            'wins': wins,
            'losses': total - wins,
            'total': total
        })
    except:
        return jsonify({'winrate': 0, 'wins': 0, 'total': 0})

@app.route('/api/logs')
def get_logs():
    # Lê as ultimas 50 linhas combinadas
    log_data = []
    files = ['scanner_bybit.log', 'monitor_bybit.log', 'executor_bybit.log']
    
    for log_file in files:
        path = os.path.join(BASE_DIR, log_file)
        if os.path.exists(path):
            try:
                with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                    lines = f.readlines()[-20:] # Ultimas 20 de cada
                    for line in lines:
                        log_data.append(f"[{log_file.split('_')[0].upper()}] {line.strip()}")
            except: pass
    
    return jsonify(log_data[-50:])  # Últimas 50 no total

if __name__ == '__main__':
    # Roda na porta 8080 para evitar conflitos
    app.run(host='0.0.0.0', port=8080, debug=False)
